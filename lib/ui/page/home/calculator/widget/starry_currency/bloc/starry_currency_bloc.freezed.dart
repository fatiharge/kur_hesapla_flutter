// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'starry_currency_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StarryCurrencyEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(StarryCurrency starryCurrency) select,
    required TResult Function(int id) diSelect,
    required TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)
        init,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(StarryCurrency starryCurrency)? select,
    TResult? Function(int id)? diSelect,
    TResult? Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(StarryCurrency starryCurrency)? select,
    TResult Function(int id)? diSelect,
    TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Clear value) clear,
    required TResult Function(_Select value) select,
    required TResult Function(_DiSelect value) diSelect,
    required TResult Function(_Init value) init,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Clear value)? clear,
    TResult? Function(_Select value)? select,
    TResult? Function(_DiSelect value)? diSelect,
    TResult? Function(_Init value)? init,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Clear value)? clear,
    TResult Function(_Select value)? select,
    TResult Function(_DiSelect value)? diSelect,
    TResult Function(_Init value)? init,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StarryCurrencyEventCopyWith<$Res> {
  factory $StarryCurrencyEventCopyWith(
          StarryCurrencyEvent value, $Res Function(StarryCurrencyEvent) then) =
      _$StarryCurrencyEventCopyWithImpl<$Res, StarryCurrencyEvent>;
}

/// @nodoc
class _$StarryCurrencyEventCopyWithImpl<$Res, $Val extends StarryCurrencyEvent>
    implements $StarryCurrencyEventCopyWith<$Res> {
  _$StarryCurrencyEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ClearImplCopyWith<$Res> {
  factory _$$ClearImplCopyWith(
          _$ClearImpl value, $Res Function(_$ClearImpl) then) =
      __$$ClearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClearImplCopyWithImpl<$Res>
    extends _$StarryCurrencyEventCopyWithImpl<$Res, _$ClearImpl>
    implements _$$ClearImplCopyWith<$Res> {
  __$$ClearImplCopyWithImpl(
      _$ClearImpl _value, $Res Function(_$ClearImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ClearImpl implements _Clear {
  const _$ClearImpl();

  @override
  String toString() {
    return 'StarryCurrencyEvent.clear()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(StarryCurrency starryCurrency) select,
    required TResult Function(int id) diSelect,
    required TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)
        init,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(StarryCurrency starryCurrency)? select,
    TResult? Function(int id)? diSelect,
    TResult? Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(StarryCurrency starryCurrency)? select,
    TResult Function(int id)? diSelect,
    TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Clear value) clear,
    required TResult Function(_Select value) select,
    required TResult Function(_DiSelect value) diSelect,
    required TResult Function(_Init value) init,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Clear value)? clear,
    TResult? Function(_Select value)? select,
    TResult? Function(_DiSelect value)? diSelect,
    TResult? Function(_Init value)? init,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Clear value)? clear,
    TResult Function(_Select value)? select,
    TResult Function(_DiSelect value)? diSelect,
    TResult Function(_Init value)? init,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class _Clear implements StarryCurrencyEvent {
  const factory _Clear() = _$ClearImpl;
}

/// @nodoc
abstract class _$$SelectImplCopyWith<$Res> {
  factory _$$SelectImplCopyWith(
          _$SelectImpl value, $Res Function(_$SelectImpl) then) =
      __$$SelectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({StarryCurrency starryCurrency});
}

/// @nodoc
class __$$SelectImplCopyWithImpl<$Res>
    extends _$StarryCurrencyEventCopyWithImpl<$Res, _$SelectImpl>
    implements _$$SelectImplCopyWith<$Res> {
  __$$SelectImplCopyWithImpl(
      _$SelectImpl _value, $Res Function(_$SelectImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? starryCurrency = null,
  }) {
    return _then(_$SelectImpl(
      starryCurrency: null == starryCurrency
          ? _value.starryCurrency
          : starryCurrency // ignore: cast_nullable_to_non_nullable
              as StarryCurrency,
    ));
  }
}

/// @nodoc

class _$SelectImpl implements _Select {
  const _$SelectImpl({required this.starryCurrency});

  @override
  final StarryCurrency starryCurrency;

  @override
  String toString() {
    return 'StarryCurrencyEvent.select(starryCurrency: $starryCurrency)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectImpl &&
            (identical(other.starryCurrency, starryCurrency) ||
                other.starryCurrency == starryCurrency));
  }

  @override
  int get hashCode => Object.hash(runtimeType, starryCurrency);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectImplCopyWith<_$SelectImpl> get copyWith =>
      __$$SelectImplCopyWithImpl<_$SelectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(StarryCurrency starryCurrency) select,
    required TResult Function(int id) diSelect,
    required TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)
        init,
  }) {
    return select(starryCurrency);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(StarryCurrency starryCurrency)? select,
    TResult? Function(int id)? diSelect,
    TResult? Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
  }) {
    return select?.call(starryCurrency);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(StarryCurrency starryCurrency)? select,
    TResult Function(int id)? diSelect,
    TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
    required TResult orElse(),
  }) {
    if (select != null) {
      return select(starryCurrency);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Clear value) clear,
    required TResult Function(_Select value) select,
    required TResult Function(_DiSelect value) diSelect,
    required TResult Function(_Init value) init,
  }) {
    return select(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Clear value)? clear,
    TResult? Function(_Select value)? select,
    TResult? Function(_DiSelect value)? diSelect,
    TResult? Function(_Init value)? init,
  }) {
    return select?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Clear value)? clear,
    TResult Function(_Select value)? select,
    TResult Function(_DiSelect value)? diSelect,
    TResult Function(_Init value)? init,
    required TResult orElse(),
  }) {
    if (select != null) {
      return select(this);
    }
    return orElse();
  }
}

abstract class _Select implements StarryCurrencyEvent {
  const factory _Select({required final StarryCurrency starryCurrency}) =
      _$SelectImpl;

  StarryCurrency get starryCurrency;

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SelectImplCopyWith<_$SelectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DiSelectImplCopyWith<$Res> {
  factory _$$DiSelectImplCopyWith(
          _$DiSelectImpl value, $Res Function(_$DiSelectImpl) then) =
      __$$DiSelectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int id});
}

/// @nodoc
class __$$DiSelectImplCopyWithImpl<$Res>
    extends _$StarryCurrencyEventCopyWithImpl<$Res, _$DiSelectImpl>
    implements _$$DiSelectImplCopyWith<$Res> {
  __$$DiSelectImplCopyWithImpl(
      _$DiSelectImpl _value, $Res Function(_$DiSelectImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
  }) {
    return _then(_$DiSelectImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DiSelectImpl implements _DiSelect {
  const _$DiSelectImpl({required this.id});

  @override
  final int id;

  @override
  String toString() {
    return 'StarryCurrencyEvent.diSelect(id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DiSelectImpl &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DiSelectImplCopyWith<_$DiSelectImpl> get copyWith =>
      __$$DiSelectImplCopyWithImpl<_$DiSelectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(StarryCurrency starryCurrency) select,
    required TResult Function(int id) diSelect,
    required TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)
        init,
  }) {
    return diSelect(id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(StarryCurrency starryCurrency)? select,
    TResult? Function(int id)? diSelect,
    TResult? Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
  }) {
    return diSelect?.call(id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(StarryCurrency starryCurrency)? select,
    TResult Function(int id)? diSelect,
    TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
    required TResult orElse(),
  }) {
    if (diSelect != null) {
      return diSelect(id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Clear value) clear,
    required TResult Function(_Select value) select,
    required TResult Function(_DiSelect value) diSelect,
    required TResult Function(_Init value) init,
  }) {
    return diSelect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Clear value)? clear,
    TResult? Function(_Select value)? select,
    TResult? Function(_DiSelect value)? diSelect,
    TResult? Function(_Init value)? init,
  }) {
    return diSelect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Clear value)? clear,
    TResult Function(_Select value)? select,
    TResult Function(_DiSelect value)? diSelect,
    TResult Function(_Init value)? init,
    required TResult orElse(),
  }) {
    if (diSelect != null) {
      return diSelect(this);
    }
    return orElse();
  }
}

abstract class _DiSelect implements StarryCurrencyEvent {
  const factory _DiSelect({required final int id}) = _$DiSelectImpl;

  int get id;

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DiSelectImplCopyWith<_$DiSelectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CurrencyType currencyType, CurrencyType calculatedCurrencyType});
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$StarryCurrencyEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currencyType = null,
    Object? calculatedCurrencyType = null,
  }) {
    return _then(_$InitImpl(
      currencyType: null == currencyType
          ? _value.currencyType
          : currencyType // ignore: cast_nullable_to_non_nullable
              as CurrencyType,
      calculatedCurrencyType: null == calculatedCurrencyType
          ? _value.calculatedCurrencyType
          : calculatedCurrencyType // ignore: cast_nullable_to_non_nullable
              as CurrencyType,
    ));
  }
}

/// @nodoc

class _$InitImpl implements _Init {
  const _$InitImpl(
      {required this.currencyType, required this.calculatedCurrencyType});

  @override
  final CurrencyType currencyType;
  @override
  final CurrencyType calculatedCurrencyType;

  @override
  String toString() {
    return 'StarryCurrencyEvent.init(currencyType: $currencyType, calculatedCurrencyType: $calculatedCurrencyType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitImpl &&
            (identical(other.currencyType, currencyType) ||
                other.currencyType == currencyType) &&
            (identical(other.calculatedCurrencyType, calculatedCurrencyType) ||
                other.calculatedCurrencyType == calculatedCurrencyType));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, currencyType, calculatedCurrencyType);

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InitImplCopyWith<_$InitImpl> get copyWith =>
      __$$InitImplCopyWithImpl<_$InitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() clear,
    required TResult Function(StarryCurrency starryCurrency) select,
    required TResult Function(int id) diSelect,
    required TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)
        init,
  }) {
    return init(currencyType, calculatedCurrencyType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? clear,
    TResult? Function(StarryCurrency starryCurrency)? select,
    TResult? Function(int id)? diSelect,
    TResult? Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
  }) {
    return init?.call(currencyType, calculatedCurrencyType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? clear,
    TResult Function(StarryCurrency starryCurrency)? select,
    TResult Function(int id)? diSelect,
    TResult Function(
            CurrencyType currencyType, CurrencyType calculatedCurrencyType)?
        init,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(currencyType, calculatedCurrencyType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Clear value) clear,
    required TResult Function(_Select value) select,
    required TResult Function(_DiSelect value) diSelect,
    required TResult Function(_Init value) init,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Clear value)? clear,
    TResult? Function(_Select value)? select,
    TResult? Function(_DiSelect value)? diSelect,
    TResult? Function(_Init value)? init,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Clear value)? clear,
    TResult Function(_Select value)? select,
    TResult Function(_DiSelect value)? diSelect,
    TResult Function(_Init value)? init,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements StarryCurrencyEvent {
  const factory _Init(
      {required final CurrencyType currencyType,
      required final CurrencyType calculatedCurrencyType}) = _$InitImpl;

  CurrencyType get currencyType;
  CurrencyType get calculatedCurrencyType;

  /// Create a copy of StarryCurrencyEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InitImplCopyWith<_$InitImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StarryCurrencyState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(StarryCurrency starry, int id) selected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(StarryCurrency starry, int id)? selected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(StarryCurrency starry, int id)? selected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Selected value) selected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Selected value)? selected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Selected value)? selected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StarryCurrencyStateCopyWith<$Res> {
  factory $StarryCurrencyStateCopyWith(
          StarryCurrencyState value, $Res Function(StarryCurrencyState) then) =
      _$StarryCurrencyStateCopyWithImpl<$Res, StarryCurrencyState>;
}

/// @nodoc
class _$StarryCurrencyStateCopyWithImpl<$Res, $Val extends StarryCurrencyState>
    implements $StarryCurrencyStateCopyWith<$Res> {
  _$StarryCurrencyStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StarryCurrencyState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$StarryCurrencyStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'StarryCurrencyState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(StarryCurrency starry, int id) selected,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(StarryCurrency starry, int id)? selected,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(StarryCurrency starry, int id)? selected,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Selected value) selected,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Selected value)? selected,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Selected value)? selected,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements StarryCurrencyState {
  const factory Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$SelectedImplCopyWith<$Res> {
  factory _$$SelectedImplCopyWith(
          _$SelectedImpl value, $Res Function(_$SelectedImpl) then) =
      __$$SelectedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({StarryCurrency starry, int id});
}

/// @nodoc
class __$$SelectedImplCopyWithImpl<$Res>
    extends _$StarryCurrencyStateCopyWithImpl<$Res, _$SelectedImpl>
    implements _$$SelectedImplCopyWith<$Res> {
  __$$SelectedImplCopyWithImpl(
      _$SelectedImpl _value, $Res Function(_$SelectedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StarryCurrencyState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? starry = null,
    Object? id = null,
  }) {
    return _then(_$SelectedImpl(
      starry: null == starry
          ? _value.starry
          : starry // ignore: cast_nullable_to_non_nullable
              as StarryCurrency,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SelectedImpl implements Selected {
  const _$SelectedImpl({required this.starry, required this.id});

  @override
  final StarryCurrency starry;
  @override
  final int id;

  @override
  String toString() {
    return 'StarryCurrencyState.selected(starry: $starry, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedImpl &&
            (identical(other.starry, starry) || other.starry == starry) &&
            (identical(other.id, id) || other.id == id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, starry, id);

  /// Create a copy of StarryCurrencyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectedImplCopyWith<_$SelectedImpl> get copyWith =>
      __$$SelectedImplCopyWithImpl<_$SelectedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(StarryCurrency starry, int id) selected,
  }) {
    return selected(starry, id);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(StarryCurrency starry, int id)? selected,
  }) {
    return selected?.call(starry, id);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(StarryCurrency starry, int id)? selected,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(starry, id);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Selected value) selected,
  }) {
    return selected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Selected value)? selected,
  }) {
    return selected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Selected value)? selected,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(this);
    }
    return orElse();
  }
}

abstract class Selected implements StarryCurrencyState {
  const factory Selected(
      {required final StarryCurrency starry,
      required final int id}) = _$SelectedImpl;

  StarryCurrency get starry;
  int get id;

  /// Create a copy of StarryCurrencyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SelectedImplCopyWith<_$SelectedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
